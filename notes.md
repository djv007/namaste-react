## Episode 1 (The Inception) : 
React fiber : is the new reconcialition algo of react that finds difference between previous and current virtual DOMS
virtual DOM : object representation of our JSX

Inception : 

Main job of all js libraries and frameworks is to optimise the most costly operation which is DOM manipulation . 
React does so by using js functions like createElement() directly which are available in browsers as browsers have js engine.

const heading = React.createElement(“h1” , {} , “hello world!”); 
console.log(heading); // object (This returns an object not a html element) - VVVI
const root = ReactDOM.createRoot(document.getElementById(“root”));

root.render(heading); 
// above line is converting heading object into html element and putting it inside root element.

We do root.render(heading); 
/ suppose root already has some html elements inside it then when we write above line , existing html elements inside root will be replaced by heading.

4 . we can use react library in existing apps as it only renders in the element we speicfy iske upar neeche kuch bhi ho skta h aur 

5 . create a repo on github and follow steps to push the code in local to git repo

In development mode, we can enable and utilize React developer tools, devtools profiler, debugging environment attached with source code. We can utilize various functionalities such as Hot Module Replacement, diagnostics so that development environment will help to debug code.

In production mode, compression and minification of Javascript and other resources happens to reduce size of the code which is not the case when it comes to development mode. Performance will be much faster in production mode when compared to development mode.




## Episode 2(Igniting the app) : 
1 . To make app prod ready , we need to have some bundler , do code chunking , image optimisation etc
2 . npm : is a package manager for js libraries and frameworks 
3 . package.json : file gets generated when we write "npm init" command and package.json is a configuration for npm .
4 . package or dependency is same thing 
5 . MI package : is a bundler(webpack , parsel , veed etc)
Bundler : packs the app so that app can be shipped to prod.
6 . we will use parcer bundler
7 . 2 types of packages/dependencies we can have 
 1 . dev dependency and normal dependency

 "npm install -D parcel"   (-D means it's a dev dependency)

8 . caret(^) and tinde(~) : u know

9 . package-lock.json : locks the version : it keeps a record of every small upgrade of the version 

10 . in package-lock.json : parcel object -> integrity : is a hash 
     it keeps a track of exact version of all packages and their dependecy packages so that we can't say it's working in my local but not in prod

11 . Transitive dependencies : As we install a package it can have other dep. and those dep. can have other dep. so no_modules can have a lot of things - like node_modules me parcel folder will have a package.json for itself and same way each dep. will have 

12 . If we have package and package-lock files : we can create node_modules folder
13 . 'npx parcel index.html'   -> index.html is the source this command will host our app at local server
14 . npx : executing a package , npm : install/uninstall a package
15 . CDN links is not a good way to get react and react dom 
16 . Now we will emove CDN links and install react and react dom via npm and import them also in respective files like app.js to use them .
17 . now we will get an error cannot have import statement in script files - as script files are treated as normal js files , now they are not , so will add type = 'module' in script tag in index.html to fix this error .
18 . when we do 'npx parcel build index.html' -> we provide index.html as entry point and in our package.json we have given App.js as main , so it's conflicting entry points so rmove app.js from package.json file 
19 . this build commands gives 3 main files - index.html/css/js - have all our code 
20 . Any code which we can re-generate don't put on git. like dist folder and .parcel-cache
21 . parcel-cache is generated by parcel to cache the code to increase speed
22 . browserslist.dev : website to configure for how many borwsers our app should work 
     for that add in package.json : browserslist : {

     }
     warning: in the working copy of 'package-lock.json', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'package.json', LF will be replaced by CRLF the next time Git touches it


## episode 3 : laying the foundation
  babel documentation read
  explore jsx how to use img and href and a tag

1 . In package.json -> add 2 scripts : start : "parcel index.html" // run in dev mode
    and build : "parcel build index.html"  // run in prod mode
start keyword reserved by npm so : npm run start and npm start are same commands 
2 . React and jsx are different : jsx is for the ease of developers 
3 . JSX is not html , it is html like syntax
4 . javascript is a code that browser's js engine understand , now jsx can't be understood by js engine , 
    js engine understands          ecmascript 6 . So , parcel is transpiling (converted to a form that browser can understand) the code so that browser can understand.
    Babel : is a js compiler or a transpiler that converts the code from 1 form to another
    parcel gives the responsibility to transpile the code to Babel - babel's job is to transpile jsx code to what browser can understand
5 . jsx is converted to react.createElement() form by babel 
    JSX => React.createElement() => ReactElement(JS-object) => HTML element(remder)
6 . Attributes in jsx are given in camelCase like tabIndex instead of tabindex 
7 . enclose jsx in () if writing in multiple lines 
8 . React components : 2 types - 
    8.1 Class based components : old
    8.2 Functional components : new
    React functional component : is just a normal js function that returns jsx(or react element as jsx and react element are same)
    name start of a react comp with a capital letter to tell react that it is a react component.
9 . COMPONENT COMPOSITION : The process to render a component inside another component .
    for ex in App.js we have a func comp Title like 
       const Title = () => <div id = "title">I am title</div>

       const HeadingComponent = () => {
        <div id = "container">
        <Title/>
        <h1 className="heading">I am heading</h1>
        </div>
       }


        <Title/>  
        <Title></Title>
        {Title()}

        above 3 are same 

       we were rendering react elements liek this till now : root.render(header); where header is a react element
       to render react func comp we will do : root.render(<HeadingComponent/>);
10 .   To write js in jsx just write {} so inside {} we can write js 
11 . If we have to put a react element inside a react comp , we can use {} as a react element is a js variable , 
     so we can put it like a js variable
12 . suppose we are executing some js data in jsx like {data} , data is coming from api and is malicious , so jsx will
     sanitise data and then will execute it preventing cross origin attacks 



## episode 04 : Code in react 

1 . How to think about building an app like a food ordering app we will build 
    we build a wireframe 
2 . first half we coded with hardcoded data
3 . then we have dynamic data 
4 . passing a prop to a comp is same as passing an arg to a func 
5 . config-driven UI : webiste is driven by data - controlling the UI using config(coming from backend)
    liek delhi , mumbai , chennai me alag alag card carousel hoga cards ka swiggy website pe 
see swiggy's api call how data is coming on homepage - helpful in system design 
6 . Always give key(reserved keyword) as id in elements whenever using map to loop (never use loop index as keys)
    : so that react can recognise each loop lement uniquely and hence re-render only newly added or modified elements not 
    other elements improving performance
7 . See how we have src attribute in img tag as images are stored in a cloud on swiggy used that url and then each restaurant 
    has imageId of it , so using that as well .
8 . Also , see how we have de-structured data from props in res card comp.


## episode 05 : hooks

1 . react files structure - read about it online what's good practices - don't overthink about folder structure
2 . 3 extensions : .js , .jsx , .tsx : doesn't matter , we will use .js 
3 . while importing no need of file extension automatic assumed h js file hi hogi - some people use .js , .jsx or .tsx extension 
    although.
4 . Never put hard coded data into components folder like we have resData and img CDN url , also in header.js -> img src string
    put in separate file , inside utils folder or common 
5 . 2 types of imports/exports :
    5.1 default : only 1 per file -> imported without {}
    export default Component;
    import Component from "path";

    5.2 named : can be multiple -> imported using {}
    export const Component;
    import {Component} from "path";
6 . Feature : create a button - on click of it we only show restaurats which are top rated (rating > 4.0)
    If we just use a let variable to store array of res. and try to call a func. on button click which updates the res. array
    then react comp won't be re-rendered.
    So, we use state variable here 
    
    HOOK : is a normal js utility function that has some superpowers(logic) by react.
    - MI hooks : useState() and useEffect()

7 . whenever a state variabel chnages - react will re-render will comp.
8 . Reconciliation algo (React fiber) : came in react 16:  react uses this algo.
    Virtual DOM : is not actual DOM , is representation of actual DOM 
    like whenever we create an elemnt in react then we get a js object . this is called virtual DOM
    Diff algo : whenever any data changes in DOM like in res-container any res changes inside it , then diff algo will find difference 
    between previous virtual dom and new virtual dom and then actually update the DOM in every render cycle.

Q : why react is fast ?
A : as react does fast DOM manipulations as it uses virtual DOM 
    virtual DOM : old concept , but react created a diff algo to find difference between previous and current virtual DOMs

in useState we are doing array destructuring on the fly 
 const [listOfRes, setListOfRes] = useState(resList);
 // above line and below 2 lines are same
 const arr = useState(resList);
 const [listOfRes, setListOfRes] = arr;



 ### Episode 06 : exploring the world
 1 . Monolith architecture : earlier web apps developed using this 
     In same project : API , UI , auth code , db connection code 
     even if we do 1 change - we need to build whole proj again
 2 . Micro-services architecture : we have different services for different jobs
     separate services : UI , api , db , email notification etc
     Separation of concern and 
     Single responsibility principle 
     All services talk to each other : we can write each micro service in different programming language
     On diff ports we can deploy diff services
     diff domains like : /api , /sms, 
 3 . How to get data from backend?
     2 ways :
     3.1 : as soon as app loads , call the api , get the data (take some time like 2 secs wait), then render the UI
     3.2 : as soon as page loads , just render UI  , then make api call and get data , then re-render the UI
     we will always be using 2nd approach in React : Its better , giving better UX 
     as first appraoch we don't see anything till 2 secs but 
     in second approach we render skeleton first then call API then again re-render UI
     As react render cycles are fast , so 2 renders are fine , so we will follow 2nd approach 
4 . useEffect hook : takes 2 args callback func and a dependency array 
    this cb func is called after the render cycle is complete(after comp is rendered)
    If you have to do something after the comp is rendered , the use useEffect()
5 . we tried to call swiggy api from our local , pasted the swiggy api url 
    got CORS error : this error is given by our browser , as it prevents us call anything from different origin
    (localhost to swiggy's origin)
    we can bypass this CORS 
    download cors chrome extension 
6 . Shimmer UI : before data comes from API , we show dummy UI - Always load a shimmer UI
7 . useState hook in depth : 
    if we chnage a state variable , then it will re-render(call again the function) the functional component 
    so return ke upar bhi jo likhenge vo execute hoga firse , but in DOM only that node gets changed where data is changed
    due to smart diff algo react fiber and reconcialiation
    diff algo will compare virtual DOMs and will find only button is changed so only it will get updated
    Q. Even though its const here , const [res,setRes] = useState([]);
       we can change state variable how , is it not violating js concepts?
    A.  when state variabel is chnaged then , re-render ke time a new copy of state variable gets created and hence in that new copy updated value of state variable gets passed through setRes() as its a new copy so const se problem nahi 

8 . we want to add a search bar (input field) with a search button so that if user types something then we search that res.
    here in input tag if we set value attribute to a state variable then if we type something in search bar it will not be reflected
    as our value is tied to state variable 
    so we add onChange event and in this we call setRes() to update the state variable passed in value attribute
9 .  now if we type something in search bar for each character typed or removed , comp will get rendered each time 
   - this is mind blowing that react is so fast rendering components so many times very fast 
    Although react is re-rendering the whole comp , in DOM it's just updating the input text value as that is chnaged only in DOM
    As DOM manipulation is expensive react does it very fast by its reconciliation algo
10 . React fiber : is the new reconcialition algo of react that finds difference between previous and current virtual DOMS
     virtual DOM : object representation of our JSX
11 . While filtering we faced a bug , ki ek baar filter kiya restaurants ko fir dobara firse textbox me kuch likhoge to vo 
     filtered res me se krega filter na ki total res the jo unme se orginally 
     as we are changing lisOfRes state variable on each time search button is clicked 
     Soln : create a separate state variable for filteredRes and use it to render all res. cards 
     also assign this new variable a value when callign API in fetchData()
     also now use original list of res in lisOfRes variable to filter data  (see code)


### Episode 6.2 : CORS issue
1 . we can use swiggy live API without installing CORS plugin in chrome 
    by appending a string in each url in fetchData() , 
    we can google CORS bypass and get it 
    free version has a limit of 40 calls/minute 

### Episode 7 . Finding the path
1 . useEffect : 
    no dependency array : called everytime comp is rendered
    empty dep arr : called once on initial mount/render of comp(just once)
    if dep array has something : called om change of these reactive variables
2 . useState() : 
        Good practices : 
            never call outside a func comp as it's used to create a local state variable in a func comp and calling it outside 
            will defeat useState hook's purpose
    # call it in start of func comp
    # Never create useState hook inside a if-else cond. - will create inconsistencies in different renders 
    # never create useState inside a function/loop

3 . Routing : 
    react router dom : library we will use
    install it : npm i react-router-dom
    # createBrowserRouter : in app.js import from this library for configuring routes ki kis url pe kaunsa comp load ho
    # provide this config. created using 
    RouterProvider : to write this : root.render(<RouterProvider router={appRouter}/>);
 
    # react router dom gives us an imp hook 
      useRouteError : to provide some extra inf about an error in react 
    # children[]  : we will use it if we want header comp always and below it about us , contact or all pages to load 
    Outlet : imported from react-router-dom (like router-outlet in angular)
    we will add outlet in app.js jsx : and this outlet will be filled with children whenever we change the path 
    # Never use <a href = "/about"> tag for routing as it will reload the whole page (in this case header comp will also be reloaded
    but it's already there)
    Use react's 
    Link component instead : works exactly same as <anchor> tag in browser DOM link jaha use kara h vaha <a> tag hi hoga 
    but Link react router dom ne ese bnaya ki page refresh nahi hota 
4 . Types of routing in web apps :
    1 . client side routing : no network call making the app SPA
    2 . server side routing : server se html aata hai (we make a network call when we load about us suppose)

5 . We will use Dynamic routing now : 
    when we click any res card : we should open its page 


### Episode 08 : Let's get classy
1 . Class based components :
    Older way to write code 
2 . class based comp : it's a normal javascript class.
    to make a js class a class based comp , we extend from React.Component
    # we have a render() : return JSX 

3 . To pass props in CBC : we use contructor and call super()
    constructur(props) {
        super(props);
        console.log(props);
    }

    and to access props in CBC : we use this.props 
    Q : Why we write super(props) always ?
    A : 

4 . How to Create state variable in CBC : 
    Loading a CBC means we are creating an isntance of the class
    state : is a reserved word in CBC 
    we create a state variable in CBC inside constructor
5 . NEVER UPDATE STATE variables directly in CBC like this.state.count = this.state.count + 1; never do this
    Do using : this.setState(
        count : this.state.count + 1,
        count2: this.state.count2 + 1
    ) : can be used anywhere in the class and we can club 2 state variables updates together
    Suppose our CBC has 4 state variables 
    and if we update only 2 out of them using setState() then other 2 state variables will not be changed

6 . CBC lifecyles hooks : 
    How a CBC is mounted(loaded) on webpage 
    1 . whenever a  CBC is mounted/rendered : 1st constructor then render() is called
    2 . some people destructures Component from React and write differently like :
        import {Component} from 'React';
        class About extends Component {}

instead of below :
        import React from 'React';
        class About extends React.Component {}


    3 . ComponentDidMount() {}
    order -> child conttsructor() , render() , ComponentDidMount() of child

    if ComponentDidMount() is in parent also like About class which is calling the child class UserClass CBC then 
    order of execution is different : imp. interview question :
    Parent Contructur , parent render , Child cons , child render , child ComponentDidMount , parent ComponentDidMount

    As parent ke JSX me hi to child component likhte h hum , to parent to poora mount tab tak nahi hoga jab tak vo children ko mount na krde apne isiliye parent ComponentDidMount last me call hoga 

    4 . ComponentDidMount() very IMP. usecase is to call APIs
      Why we do so?
      A . As YK we first render the comp then call API then again render the comp. with API's data 
      So that comp is rendered and doesn't wait for API to get the data 

    5 . React lifecycle diagrams : note the website 
    Supppose About CBC is calling user CBC twice then order of excution of methods changes like this : 

    Parent constructor
    Parent render

        Child1 constructor
        Child1 render
        Child2 constrcutor
        Child2 render

        Child1 compDidMount
        Child2 CompDidMount
    Parent CompDidMount

    Here , React is optimising things 
    as there are 2 phases :
    1 . Render phase : (calling contruc, render)
    2 . Commit phase : (calling CompDidMount() of children)

    So, React is batching render phase for multiple children

    Render phase is very fast but commit phase takes timr 
    In render phase react reconcialition algo is running comparing virtual doms which are js objects so we are batching render phases
    of children 
    So that we need not to update DOM again and again as DOM manipulation is heavy .

    In COmmit phase : we start updtaing the DOM as in render phase whic happens prior we have decied hwo to update the DOM 
    finally as all children render phases were batched 

6 . How to make API calls in CBC : 
    # Create a state variable(which will be an obj)
    # call githib user api and setState variable to the data we receive
    # in render() use state variable to display data 

     (refer to diagram) : 
    In Mounting phase : Comp is rendered with dummy data 
    In Updating phase : when any state variable is chnaged comp is rendered with the data it receives
    ComponentDidUpdate() is called when any state variable is chnaged and comp is rendered again 
    In Unmounting phase : 
    ComponentWillUnmount() will be called just before we unmount the comp by clciking somewhere else 
    ComponentWillUnmount() : to do clean up like if componentDidMount() me koi setInterval() hai to 
    jitni baar hum aaenge is comp me ye render hoga utni baar new setInterval will be created each time 
    so we have to clear interval in componentWillUnmount()

    Disclaimer : 
    NEVER compare react lifecycle methods with func components hooks
    Mount , Update , Unmount different hai CBC me 
    first mount of comp pe compDidMount() called
    after further renders compDidUpdate() is called


